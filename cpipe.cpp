#include "cpipe.h"
//#include <QGraphicsScene>
#include <QPainter>
#include <QStyleOption>
#include "cadvgraphicsview.h"
#include <qgraphicsscene.h>
#include <QGraphicsSceneMouseEvent>
#include <qmenu.h>
#include <QComboBox>
#include <globals.h>
#include "undocommands.h"

#include <qloggingcategory.h>
Q_DECLARE_LOGGING_CATEGORY(Pipe)
Q_LOGGING_CATEGORY(Pipe, "pipe ")


CPipe::CPipe() :CPathElement ()
{

    m_NormalPen.setColor(Qt::white);
    m_NormalPen.setBrush(QBrush(Qt::white,Qt::SolidPattern));
    m_NormalPen.setStyle(Qt::SolidLine);
    m_NormalPen.setWidth(2);

    m_SelectedPen.setColor(Qt::yellow);
    m_SelectedPen.setBrush(QBrush(Qt::yellow, Qt::SolidPattern));//Dense4Pattern));
    m_SelectedPen.setStyle(Qt::DashLine);
    m_SelectedPen.setWidth(2);

    m_ElementType = Pipe;

    setPipeType(Pipef110);

}

CPipe::~CPipe()
{
}


CPipe::PipeType CPipe::getPipeType() const
{
    return m_PipeType;
}

void CPipe::setPipeType(const PipeType &PipeType)
{
    m_PipeType = PipeType;
    switch (PipeType) {
    case Pipef110:
        m_pipeR = 5.5;
        break;
    case Pipef32:
        m_pipeR = 1.6;
        break;
    case Pipef20:
        m_pipeR = 1;
        break;
    case Pipef50:
        m_pipeR = 2.5;
        break;
    case PipeCustom:
            ;

    }
}
void CPipe::preparePainterPath()
{
    m_PainterPath = QPainterPath();
    m_Shape = QPainterPath(); //a path requred for selection with the mouse. returned by shape()
    //Paint first parrallel
    paintFirst();
    m_Shape = m_Shape.toReversed(); //Reverse the shape, generated by paintFirst()

    //draw the circle at the beggining of the pipe
    m_PainterPath.moveTo(m_pPath->point);
    m_PainterPath.addEllipse(m_pPath->point,m_pipeR,m_pipeR);

    //Advance at the position of the element
    m_PainterPath.moveTo(m_pPath->point);
    paintSecond();
    //Find the last point of the element, and draw a circle there
    CPathPoint * p = m_pPath;
    while (p->next)
        p = p->next;
    m_PainterPath.moveTo(p->point);
    m_PainterPath.addEllipse(p->point,m_pipeR,m_pipeR);

    //Set the tootip at the end
    QString strTip ("Pipe: ");
    strTip.append(getElementName());
    strTip.append("\n Diameter: ");
    strTip.append(QString::number(m_pipeR * 20,'f',2)); //radius*2*10 in mm
    strTip.append(" mm\n Length: ");
    strTip.append(QString::number(m_Length/100,'f',2));
    strTip.append (" m.");
    setToolTip(strTip);
}

void CPipe::paintFirst()
{
    //calc first parallel

     QPointF startA,endA;
     QPointF startB,endB;
     QPointF isec;

     CPathPoint * ppoint = m_pPath;


     while (ppoint->next)
     {
        startA = ppoint->point;
        endA = ppoint->next->point;

        calcPar(startA,endA,m_pipeR);

        if (!isec.isNull()) //start line has not intersection point.
            startA = isec;  //Start drawing at interception point

        if (ppoint->next->next)
        { // Not the end. Get next
            startB = ppoint->next->point;
            endB = ppoint->next->next->point;
            //Calc next line
            calcPar(startB,endB,m_pipeR);

            //find intersection point, and set as end of the current and beggining of then next
            isec = intersection(startA,endA,startB,endB);
            endA =isec;
         }

        m_PainterPath.moveTo(startA);
        m_PainterPath.lineTo(endA);

        m_Shape.lineTo(startA);
        m_Shape.lineTo(endA);

        ppoint = ppoint->next;
     }
     m_Shape.lineTo(ppoint->point);
}

void CPipe::paintSecond()
{
    //draw second parallel
    QPointF startA,endA;
    QPointF startB,endB;
    QPointF isec;
    QPainterPath tmp;

    CPathPoint * ppoint = m_pPath;

    m_Length = 0; // lenght of the pipe will be calculated with CalcPar

    while (ppoint->next)
    {
       startA = ppoint->point;
       endA = ppoint->next->point;

       calcPar(startA,endA,-m_pipeR);

       if (!isec.isNull()) //start line has not interception point.
           startA = isec;  //Start drawing at interception point

       if (ppoint->next->next)
       { // Not the end. Get next
           startB = ppoint->next->point;
           endB = ppoint->next->next->point;
           //Calc next line
           calcPar(startB,endB,-m_pipeR);

           //find intersection point, and set as end of the current and beggining of then next
           isec = intersection(startA,endA,startB,endB);
           endA =isec;
        }
        //The second part of the shape's path
       tmp.lineTo(startA);
       tmp.lineTo(endA);

        m_PainterPath.moveTo(startA);
        m_PainterPath.lineTo(endA);

       ppoint = ppoint->next;
    }
    tmp.lineTo(ppoint->point);
    // Add the second part of the path to the shape's path
    m_Shape.addPath( tmp);

}
void CPipe::calcPar(QPointF &A, QPointF &B,int offset)
{
    //Equation of a line.
    //Translates vertically the line (A to B) with offset
    qreal l;
    l = pow (B.x() - A.x(),2);
    l = l + pow(B.y() - A.y(),2);
    l = sqrt(l);
    qreal v = B.y()-A.y();
    qreal h = A.x()-B.x();

    A.setX(A.x() + offset * v/l);
    B.setX(B.x() + offset *  v/l);

    A.setY(A.y()+offset * h /l);
    B.setY(B.y() + offset *  h/l);

    m_Length = m_Length + l; // calculate the length in pixels
}

QPainterPath CPipe::shape() const
{

    return m_Shape;
}

QJsonObject& CPipe::getSaveValue()
{
    CPathElement::getSaveValue();
    m_Data.insert("pipe_tp",QJsonValue(getPipeType()));
    return m_Data;
}

void CPipe::LoadElement(const QJsonObject& obj)
{

    setPipeType( (PipeType) obj["pipe_tp"].toInt());
    CPathElement::LoadElement(obj);
}
void CPipe::contextMenuEvent(QGraphicsSceneContextMenuEvent *event)
{

    CPathElement::contextMenuEvent(event);
}

void CPipe::configureContextMenu(QMenu *pMenu)
{



    QMenu *pSub = pMenu->addMenu("Pipe type");
    pSub->addAction("110 mm")->setData(QVariant(1));
    pSub->addAction("50 mm")->setData(QVariant(2));
    pSub->addAction("32 mm")->setData(QVariant(3));
    pSub->addAction("20 mm")->setData(QVariant(4));
    pMenu->addSeparator();
    CPathElement::configureContextMenu(pMenu);
}

void CPipe::contextMenuAction(QAction * pAction)
{
    if (!pAction)
        return;
    int i = pAction->data().toInt();
    CUndoPropChange *pUndo;
    if (i > 0 && i < 5)
    {
        pUndo = new CUndoPropChange(scene()->selectedItems());
        pUndo->setText("Change pipe diameter");
    }

    switch (i)
    {
    case 1 :
        setPipeType(Pipef110);

        break;
    case 2:
        setPipeType(Pipef50);
        break;
    case 3:
        setPipeType(Pipef32);
        break;
    case 4:
        setPipeType(Pipef20);
        break;
    }
    if (i > 0 && i < 5)
    {
        pUndo->finishPropChange();
        g_UndoStack->push(pUndo);
        preparePainterPath();
        prepareGeometryChange();
    }

    CPathElement::contextMenuAction(pAction);

}

bool CPipe::isConnectionAccepted(CElement *other)
{
    if (m_Connections.count() < 2)
        return CPathElement::isConnectionAccepted(other);
    return false;
}

ElementProperties* CPipe::getElementProperties()
{
    ElementProperties *pRet = CPathElement::getElementProperties();
    EProp * pProp;
    QComboBox *tp = new QComboBox;

    pProp = new EProp;
    pProp->Name = "Pipe diam.";
    pProp->pEditor = tp;
    tp->setEditable(false);
    tp->addItem("110mm");
    tp->addItem("50mm");
    tp->addItem("32mm");
    tp->addItem("20mm");
    tp->setCurrentIndex(getPipeType());
    pRet->append(pProp);
    return pRet;
}

void CPipe::setElementProperties(ElementProperties * pProp)
{
    int tp = dynamic_cast<QComboBox *>(pProp->byName("Pipe diam.")->pEditor)->currentIndex();
    setPipeType((PipeType) tp);
    preparePainterPath();
    CPathElement::setElementProperties(pProp);

}

